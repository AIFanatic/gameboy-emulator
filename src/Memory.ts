import { MBC, MBCType } from "./MBC";
import { Timer } from "./Timer";

export class Memory {
    public readonly BIOS = [
        0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
        0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
        0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
        0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
        0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
        0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
        0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
        0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
        0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
        0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
        0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
        0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
        0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
        0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
        0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
        0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
    ];
    
    private mbc: MBC;
    public memory = new Array(0xFFFF).fill(0);
    public rom: Uint8Array;


    public timer: Timer;

    public _romoffs = 0;

    constructor() {
    }

    public reset() {
        for (var i = 0x8000; i <= 0x9FFF; i++) {
            this.memory[i] = 0;
        }
        for (var i = 0xFF00; i <= 0xFF7F; i++) {
            this.memory[i] = 0;
        }
        this[0xFFFF] = 0;
    }

    private getGameName() {
        var name = '';
        for (var i = 0x134; i < 0x143; i++) {
            var char = this.rb(i) || 32;
            name += String.fromCharCode(char);
        }
    
        return name;
    };

    private getRamSize() {
        var size = 0;
        switch (this.rb(0x149)) {
            case 1:
                size = 2048;
                break;
            case 2:
                size = 2048 * 4;
                break;
            case 3:
                size = 2048 * 16;
                break;
        }
    
        return size;
    };

    public loadRom(data: Uint8Array) {
        this.reset();

        this.rom = data;
        for (var i = 0; i < 0x4000; i++) {
            this.memory[i] = this.rom[i];
        }

        this.mbc = MBC.getMbcInstance(this, this.rom[0x147]);
        this.mbc.loadRam(this.getGameName(), this.getRamSize());
    }

    // Read a byte from memory
    public rb(addr: number) {
        if ((addr >= 0xA000 && addr < 0xC000)) {
            return this.mbc.readRam(addr);
        }
        else if (addr >= 0x4000 && addr <= 0x7FFF) {
            // // This is weird, invesigate
            return this.rom[this._romoffs + (addr - (this._romoffs != 0 ? 0x4000 : 0))];
            // if (this.mbc.type == MBCType.MBC0 || this.mbc.type == MBCType.MBC1) {
            //     return this.rom[this._romoffs + addr];
            // }
            // else {
            //     return this.rom[this._romoffs + (addr & 0x3FFF)];
            // }
        }

        return this.memory[addr];
    }

    // Read a 16-bit word
    public rw(addr) {
        return this.rb(addr) | (this.rb(addr + 1) << 8);
    }

    // Read a byte from memory
    public wb(addr: number, value: number) {
        if (addr < 0x8000 || (addr >= 0xA000 && addr < 0xC000)) { // MBC
            this.mbc.manageWrite(addr, value);
        }
        else if (addr == 0xFF00) { // input register
            this.memory[addr] = ((this[addr] & 0x0F) | (value & 0x30));
        }
        else {
            this.memory[addr] = value;
    
            if (addr == 0xFF04) {
                // console.warn("0xFF04 - Timer reset not implemented.");
                this.timer.resetDiv();
            }
            else if (addr == 0xFF46) { // OAM DMA transfer
                // console.log("DMA", value.toString(16))
                this.dmaTransfer(value);
            }
        }
    }

    // Start a DMA transfer (OAM data from cartrige to RAM)
    private dmaTransfer(startAddressPrefix) {
        const OAM_START = 0xFE00;
        const OAM_END = 0xFE9F;

        var startAddress = (startAddressPrefix << 8);
        for (var i = 0; i < 0xA0; i++) {
            this.memory[OAM_START + i] = this.memory[startAddress + i];
        }
    };

    public ww(addr, val) {
        this.wb(addr, val & 255);
        this.wb(addr + 1, val >> 8);
    }

    // Helpers
    public readByte(address: number): number {
        return this.rb(address);
    }

    public readWord(address: number): number {
        return this.rw(address);
    }

    public writeByte(address: number, value: number) {
        this.wb(address, value);
    }

    public writeWord(address: number, value: number) {
        this.ww(address, value);
    }
};